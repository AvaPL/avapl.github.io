---
title: Writing clean tuples
date: 2022-10-08 12:00:00 +0000
categories: [Blog]
tags: [scala, clean code, tips]     # TAG names should always be lowercase
img_path: /assets/img/2022-10-08-tuples/
---

How many times you wondered what is hidden under `._1` in a line of code?
How many `filter` conditions were not clear because they relied on tuple
accessors? Using tuples is quite easy, although it creates many
opportunities to write something nasty. This post contains tips that will
help you improve the readability of your tuples.

![Three fluffy monsters](three_fluffy_monsters.png){: w="400"}

## It's all about naming

Let's start with something simple. You have a list of ints and want to
divide them into a group of the ones that are smaller than 0 and ones
that are greater or equal 0. The simplest solution would be something
like this:

```scala
val ints = List(-4, 1, -2, 0, 5)
val partitionedInts = ints.partition(_ < 0)
```

We are using
[`List#partition`](https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#partition(p:A=%3EBoolean):(List[A],List[A]))
here. It returns a tuple with elements that satisfy the given condition,
and with those that don't. But how can we tell which group we will get
by using `partitionedInts._1`? We have to look into documentation, it is
not clear just by looking at the code. Sometimes it's not even obvious
that a particular line returns a tuple, and even if it does, we may not
know the arity of the tuple.

A cleaner way to write this is to name each part of the result:

```scala
val (lessThan0, greaterOrEqual0) = ints.partition(_ < 0)
```

This way we see at the first glance what we get in the tuple, and we
know it's arity. We don't have to look into the documentation at all!
What is more, we don't have to deal with the tuple accessors (`_1` and
`_2`) in the following lines.

## Ignoring parts of the result

Sometimes, we may want to ignore a part of the result. Let's say that
we call some external library that returns an HTTP response that is
represented as a tuple of a status code, headers and the response entity.
Then, we want to decode the response entity to JSON.

```scala
val httpResponse = sendHttpRequest(httpRequest)
val json         = decode(httpResponse._3)
```

How do we know that `httpResponse._3` is the encoded JSON body that we
care about? We may guess that only by the `json` used as the variable
name. We can do it better:

```scala
val (_, _, responseEntity) = sendHttpRequest(httpRequest)
val json                   = decode(responseEntity)
```

Now it is clear what we are decoding. The code is also not cluttered
with the information that the method returns additional information
as we use `_` placeholders here that let us ignore the status code
and the headers that we are not using.

### When the tuple is bigger

When the arity of the tuple is high, we may not want to write a long
list of underscores to ignore the majority of elements. In such case,
we can use a tuple accessor and assign the value to a new variable
that has a meaningful name:

```scala
val httpResponse   = sendHttpRequest(httpRequest)
val responseEntity = httpResponse._3
val json           = decode(responseEntity)
```

## Meaningful method names and type aliases

Deconstruction of the result is only one side where the readability
can be improved. The other one is of course the method itself. Let's
look at three levels of improving the methods' readability.

### Level 0

```scala
def readContactInfo(userId: UUID): (String, String) =
  ("john@doe.com", "123 456 789")
```

This is the staring point. We have a method that returns contact info
(that most likely is fetched from a database or an API) in a form of
a tuple of an email and a phone number. We have to look into method's
body to tell what is inside the `(String, String)` tuple.

### Level 1 - a meaningful method name

```scala
def readEmailAndPhoneNumber(userId: UUID): (String, String) =
  ("john@doe.com", "123 456 789")
```

Of course, the easiest way to improve the method is to use a better
name. This way we have a hint on the result type.

### Level 2 - type aliases

```scala
type Email       = String
type PhoneNumber = String

def readEmailAndPhoneNumber(userId: UUID): (Email, PhoneNumber) =
  ("john@doe.com", "123 456 789")
```

To make it even cleaner, we can introduce type aliases. Here, the
returned values are obvious just by looking at the return type.
We've hidden that the returned values are `String`s though, so
decide wisely if it fits your design.

## Pattern matching and for comprehensions

Often, tuples are just an intermediate structure that we are
working on in a chain of operations. Again, naming to the rescue!

Let's say that we want to filter out some of our contact
information tuples that were given to us, and we cannot modify
them:

```scala
val contactInfos = userIds.map(readEmailAndPhoneNumber)
```

It can be achieved with a simple one liner:

```scala
contactInfos.filter(_._2.startsWith("48"))
```

You may already know what we are going to simplify there - the
filter condition as it contains a mystery `_2`. The easiest way
is to just use a `case` with variable names:

```scala
contactInfos.filter {
  case (email, phoneNumber) => phoneNumber.startsWith("48")
}
```

If our use case requires also some mapping, like dropping the
first 2 digits of the number we can go further with either
`collect` or a for comprehension:

```scala
contactInfos.collect {
  case (email, phoneNumber) if phoneNumber.startsWith("48") =>
    (email, phoneNumber.drop(2))
}
```

```scala
for {
  (email, phoneNumber) <- contactInfos if phoneNumber.startsWith("48")
} yield (email, phoneNumber.drop(2))
```

This gives us more flexibility and cleaner code at the same time.

> In Scala 3, you can omit `case` in `filter` and `collect` conditions.
{: .prompt-tip }

## Keep your tuples structure simple
